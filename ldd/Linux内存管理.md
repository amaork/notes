# Linux内存管理

## 一、概述

内核中的保留空间主要用来存放内核的静态内核数据结构和映射硬件的I/O共享内存，以及BIOS数据（参考UTLK 图8.1）

## 二、32位体系结构中的内存空间的划分

1. DMA内存（小于16M的内存区间，受限于ISA设备，PCI不受此限制）
2. 常规内存（大于16M小于896M）
3. 高端内存（大于89M6的内存空间，内核中不能直接访问，需要通过映射才能访问，高端内存通常是供用户空间使用的）

## 三、内核中常用的内存申请分配函数

1. kmalloc 分配的内存在物理上是连续的， 能处理的最小内存块是32或是64取决于硬件体系结构所使用的页面的大小 最大能申请到128K的内存空间；

2. \_\_get\_free\_pages 分配的内存在物理上连续的，以页为单位的，申请的时候使用以2的为底的对数表示要申请的页数，（最大值到10 = 1024页即4M空间）通过"/proc/buddyinfo"可看到每个阶数据块的数目；

3. dma\_alloc\_coherent 分配用来做DMA操作的内存，其内部是调用了\_\_get\_free\_pages函数，所以它申请的内存空间也受限于4M的限制；

## 四、在内核中申请大于4M的空间

使用内核中提供的内存申请函数，能申请到的物理地址连续的最大的内存空间为4M，为了获得更大的内存空间有3种方法:

1. 申请多个小于等于4M的内存块，然后使用分散、积聚映射，这种方式需要硬件的支持；

2. 在内核引导的时候在调用mem\_init函数之前，调用alloc\_bootmem申请内存，但是这种方法申请内存的代码必须链接到内核中去，内核需要重新编译；

3. 在内核启动参数处指明mem=size(M)来保留顶部内存区（这个区域不受内核的内存管理），然后在内核中使用ioremap函数，将预留物理的内存地址映射到内核的虚拟地址中来使用；

## 五、申请大于4M空间内存的例子

物理内存的大小为2G，我们需要在内核中使用16M的连续物理内存。那么可以在内核启动的时候指定：mem=2000M然后启动内核，这样物理内存顶端的48M就可以保留下来了，然后在驱动程序中使用 ioremap(0x7D000000, 0x1000000)来申请这段内存，通过ioremap函数返回的地址就是内核的虚拟地址，可以通过这个地址操作内存就可以操作到物理内存顶端的16M的空间。这个方法是申请大容量物理内存最简单的方法，即标题四中的第三种方法。

## 六、内核地址地址类型

内核在x86体系结构下，将4GB的虚拟地址以3:1的比例分割为用户空间和内核空间，在两者的上下文中使用相同的映射。内核空间最大部分是物理内存的虚拟映射，内核对任何空间的访问，必须使用自己的虚拟地址（地址大于0xC0000000的地址）。所以内核能处理的最大物理内存的数量就是映射到内核的虚拟地址的部分再减去内核自身所占用的大小，所以内核不能直接处理高端内存，需要通过固定映射或是动态映射到内核空间可以访问的地址空间中进行访问，而且一次只能访问一个区域。

1. **内核逻辑地址**：映射了部分或全部的内存，逻辑地址与物理地址之间是一一对应的，存在线性映射关系，它们之间存在一个固定的偏移量，如kmalloc返回的地址；

2. **内核虚拟地址**：虚拟地址与物理地址之间不必是一一对应的，映射也不必是线性的，如vmalloc返回的地址；




